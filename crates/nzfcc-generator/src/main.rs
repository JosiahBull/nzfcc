//! Code generator for the NZFCC crate.
//!
//! This tool downloads the latest NZFCC categories from nzfcc.org and generates
//! Rust enum definitions for use in the nzfcc crate.

use std::collections::HashSet;
use std::fs::File;
use std::io::Write;
use std::path::PathBuf;
use std::process::Command;

const CATEGORIES_URL: &str = "https://nzfcc.org/downloads/categories.json";

#[derive(Debug, serde::Deserialize, serde::Serialize, Clone)]
#[serde(deny_unknown_fields)]
struct Category {
    #[serde(rename = "_id")]
    id: String,
    name: String,
    groups: Groups,
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Clone)]
#[serde(deny_unknown_fields)]
struct Groups {
    personal_finance: Group,
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Clone)]
#[serde(deny_unknown_fields)]
struct Group {
    #[serde(rename = "_id")]
    id: String,
    name: String,
}

fn construct_group_enum(groups: &[Group]) -> String {
    let mut enum_def =
        String::from("// This file is generated by nzfcc-generator. Do not edit manually.\n");
    enum_def.push_str("// Run: cargo run -p nzfcc-generator to regenerate\n\n");
    enum_def.push_str("/// An enum of the possible NZFCC category groups.\n");
    enum_def.push_str("#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n");
    enum_def.push_str(
        "#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n",
    );
    enum_def.push_str("#[cfg_attr(feature = \"serde\", serde(deny_unknown_fields))]\n");
    enum_def.push_str("#[non_exhaustive]\n");
    enum_def.push_str("pub enum CategoryGroup {\n");
    for Group { name, .. } in groups {
        let enum_name = name
            .chars()
            .filter(|c| c.is_alphanumeric())
            .filter(|c| !c.is_whitespace())
            .collect::<String>();
        enum_def.push_str(&format!("    /// The \"{}\" group.\n", name));
        enum_def.push_str(&format!(
            "    #[cfg_attr(feature = \"serde\", serde(rename = \"{}\"))]\n",
            name
        ));
        enum_def.push_str(&format!("    {},\n", enum_name));
    }
    enum_def.push_str("}\n");

    // Add a conversion from CategoryGroup to Id
    enum_def.push_str("\n");
    enum_def.push_str("impl CategoryGroup {\n");
    enum_def.push_str("    /// Returns the ID of the category group.\n");
    enum_def.push_str("    /// Category group ID strings are always prefixed by `group_`.\n");
    enum_def.push_str("    pub const fn id(&self) -> &'static str {\n");
    enum_def.push_str("        match self {\n");
    for Group { name, id } in groups {
        let enum_name = name
            .chars()
            .filter(|c| c.is_alphanumeric())
            .filter(|c| !c.is_whitespace())
            .collect::<String>();
        enum_def.push_str(&format!("            Self::{} => \"{}\",\n", enum_name, id));
    }
    enum_def.push_str("        }\n");
    enum_def.push_str("    }\n");
    enum_def.push_str("}\n");

    enum_def
}

fn construct_nzfcc_code_enum(categories: &[Category]) -> String {
    let mut enum_def = String::new();
    enum_def.push_str("// This file is generated by nzfcc-generator. Do not edit manually.\n");
    enum_def.push_str("// Run: cargo run -p nzfcc-generator to regenerate\n\n");
    enum_def.push_str("/// All possible New Zealand Financial Category Codes (NZFCC) codes, as defined by the NZFCC org [https://nzfcc.org/explore/](https://nzfcc.org/explore/).\n");
    enum_def.push_str("#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n");
    enum_def.push_str(
        "#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n",
    );
    enum_def.push_str("#[cfg_attr(feature = \"serde\", serde(deny_unknown_fields))]\n");
    enum_def.push_str("#[non_exhaustive]\n");
    enum_def.push_str("pub enum NzfccCode {\n");
    for Category { name, .. } in categories {
        let enum_name = name
            .split_whitespace()
            .flat_map(|word| {
                let mut chars = word.chars();
                let first = chars.next().map(|c| c.to_ascii_uppercase());
                first.into_iter().chain(chars)
            })
            .filter(|c| c.is_alphanumeric())
            .collect::<String>();

        enum_def.push_str(&format!("    /// The \"{}\" category.\n", name));
        enum_def.push_str(&format!(
            "    #[cfg_attr(feature = \"serde\", serde(rename = \"{}\"))]\n",
            name
        ));
        enum_def.push_str(&format!("    {},\n", enum_name));
    }
    enum_def.push_str("}\n");

    // Add a conversion from NzfccCode to Id
    enum_def.push_str("\n");
    enum_def.push_str("impl NzfccCode {\n");
    enum_def.push_str("    /// Returns the ID of the NZFCC code.\n");
    enum_def.push_str("    /// NZFCC IDs start with `nzfcc_`.\n");
    enum_def.push_str("    pub const fn id(&self) -> &'static str {\n");
    enum_def.push_str("        match self {\n");
    for Category { name, id, .. } in categories {
        let enum_name = name
            .split_whitespace()
            .flat_map(|word| {
                let mut chars = word.chars();
                let first = chars.next().map(|c| c.to_ascii_uppercase());
                first.into_iter().chain(chars)
            })
            .filter(|c| c.is_alphanumeric())
            .collect::<String>();
        enum_def.push_str(&format!("            Self::{} => \"{}\",\n", enum_name, id));
    }
    enum_def.push_str("        }\n");
    enum_def.push_str("    }\n");
    enum_def.push_str("}\n");

    enum_def
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("Downloading categories from {}...", CATEGORIES_URL);

    // Download categories.json
    let response = reqwest::blocking::get(CATEGORIES_URL)?;
    let categories_json = response.text()?;

    // Parse the JSON
    let categories: Vec<Category> = serde_json::from_str(&categories_json)?;
    println!("Successfully downloaded {} categories", categories.len());

    // Determine workspace root early
    let manifest_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    let workspace_root = manifest_dir.parent().unwrap().parent().unwrap();

    // Save formatted JSON to repository for version tracking
    let categories_json_path = workspace_root.join("categories.json");
    let formatted_json = serde_json::to_string_pretty(&categories)?;
    std::fs::write(&categories_json_path, formatted_json)?;
    println!("  ✓ Saved categories.json to repository");

    // Find all unique group names
    let mut seen_groups = HashSet::new();
    let filtered_groups = categories
        .iter()
        .map(|cat| &cat.groups.personal_finance)
        .filter(|group| seen_groups.insert(&group.id))
        .cloned()
        .collect::<Vec<Group>>();

    println!("Found {} unique category groups", filtered_groups.len());

    // Generate the enums
    let group_enum = construct_group_enum(&filtered_groups);
    let nzfcc_enum = construct_nzfcc_code_enum(&categories);

    // Determine output directory
    let output_dir = workspace_root.join("crates/nzfcc/src/generated");

    // Write files
    println!("Writing generated files to {}...", output_dir.display());
    std::fs::create_dir_all(&output_dir)?;

    let category_groups_path = output_dir.join("category_groups.rs");
    let mut f = File::create(&category_groups_path)?;
    f.write_all(group_enum.as_bytes())?;
    println!("  ✓ category_groups.rs");

    let nzfcc_codes_path = output_dir.join("nzfcc_codes.rs");
    let mut f = File::create(&nzfcc_codes_path)?;
    f.write_all(nzfcc_enum.as_bytes())?;
    println!("  ✓ nzfcc_codes.rs");

    // Run cargo fmt on the generated files
    println!("Formatting generated files...");
    let fmt_status = Command::new("cargo")
        .arg("fmt")
        .arg("--")
        .arg(&category_groups_path)
        .arg(&nzfcc_codes_path)
        .status();

    match fmt_status {
        Ok(status) if status.success() => {
            println!("  ✓ Formatted successfully");
        }
        Ok(status) => {
            eprintln!("  ⚠ cargo fmt exited with status: {}", status);
        }
        Err(e) => {
            eprintln!("  ⚠ Failed to run cargo fmt: {}", e);
            eprintln!("    Generated files may not be formatted");
        }
    }

    println!("\n✓ Code generation complete!");
    println!("  Generated {} category groups", filtered_groups.len());
    println!("  Generated {} NZFCC codes", categories.len());

    Ok(())
}
