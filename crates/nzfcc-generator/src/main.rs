//! Code generator for the NZFCC crate.
//!
//! This tool downloads the latest NZFCC categories from nzfcc.org and generates
//! Rust enum definitions for use in the nzfcc crate.

use std::collections::HashSet;
use std::fs::File;
use std::io::Write;
use std::path::PathBuf;
use std::process::Command;

const CATEGORIES_URL: &str = "https://nzfcc.org/downloads/categories.json";

#[derive(Debug, serde::Deserialize, serde::Serialize, Clone)]
#[serde(deny_unknown_fields)]
struct Category {
    #[serde(rename = "_id")]
    id: String,
    name: String,
    groups: Groups,
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Clone)]
#[serde(deny_unknown_fields)]
struct Groups {
    personal_finance: Group,
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Clone)]
#[serde(deny_unknown_fields)]
struct Group {
    #[serde(rename = "_id")]
    id: String,
    name: String,
}

fn construct_group_enum(groups: &[Group], categories: &[Category]) -> String {
    let mut enum_def =
        String::from("// This file is generated by nzfcc-generator. Do not edit manually.\n");
    enum_def.push_str("// Run: cargo run -p nzfcc-generator to regenerate\n\n");
    enum_def.push_str("/// An enum of the possible NZFCC category groups.\n");
    enum_def.push_str("#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n");
    enum_def.push_str("#[non_exhaustive]\n");
    enum_def.push_str("pub enum CategoryGroup {\n");
    for Group { name, .. } in groups {
        let enum_name = name
            .chars()
            .filter(|c| c.is_alphanumeric())
            .filter(|c| !c.is_whitespace())
            .collect::<String>();
        enum_def.push_str(&format!("    /// The \"{}\" group.\n", name));
        enum_def.push_str(&format!("    {},\n", enum_name));
    }
    enum_def.push_str("}\n");

    // Generate static arrays for each group containing all codes in that group
    enum_def.push_str("\n");
    for Group { name, id } in groups {
        let group_enum_name = name
            .chars()
            .filter(|c| c.is_alphanumeric())
            .filter(|c| !c.is_whitespace())
            .collect::<String>();

        // Find all categories that belong to this group
        let codes_in_group: Vec<String> = categories
            .iter()
            .filter(|cat| cat.groups.personal_finance.id == *id)
            .map(|cat| {
                cat.name
                    .split_whitespace()
                    .flat_map(|word| {
                        let mut chars = word.chars();
                        let first = chars.next().map(|c| c.to_ascii_uppercase());
                        first.into_iter().chain(chars)
                    })
                    .filter(|c| c.is_alphanumeric())
                    .collect::<String>()
            })
            .collect();

        let const_name = format!("CODES_{}", group_enum_name.to_uppercase());
        enum_def.push_str(&format!("const {}: &[super::NzfccCode] = &[\n", const_name));
        for code in &codes_in_group {
            enum_def.push_str(&format!("    super::NzfccCode::{},\n", code));
        }
        enum_def.push_str("];\n\n");
    }

    // Add a conversion from CategoryGroup to Id
    enum_def.push_str("impl CategoryGroup {\n");
    enum_def.push_str("    /// Returns the ID of the category group.\n");
    enum_def.push_str("    /// Category group ID strings are always prefixed by `group_`.\n");
    enum_def.push_str("    pub const fn id(&self) -> &'static str {\n");
    enum_def.push_str("        match self {\n");
    for Group { name, id } in groups {
        let enum_name = name
            .chars()
            .filter(|c| c.is_alphanumeric())
            .filter(|c| !c.is_whitespace())
            .collect::<String>();
        enum_def.push_str(&format!("            Self::{} => \"{}\",\n", enum_name, id));
    }
    enum_def.push_str("        }\n");
    enum_def.push_str("    }\n");

    // Add method to get all codes in this group
    enum_def.push_str("\n");
    enum_def.push_str("    /// Returns all NZFCC codes that belong to this category group.\n");
    enum_def.push_str("    pub const fn codes(&self) -> &'static [super::NzfccCode] {\n");
    enum_def.push_str("        match self {\n");
    for Group { name, .. } in groups {
        let enum_name = name
            .chars()
            .filter(|c| c.is_alphanumeric())
            .filter(|c| !c.is_whitespace())
            .collect::<String>();
        let const_name = format!("CODES_{}", enum_name.to_uppercase());
        enum_def.push_str(&format!(
            "            Self::{} => {},\n",
            enum_name, const_name
        ));
    }
    enum_def.push_str("        }\n");
    enum_def.push_str("    }\n");
    enum_def.push_str("}\n");

    // Manually implement Serialize
    enum_def.push_str("\n");
    enum_def.push_str("#[cfg(feature = \"serde\")]\n");
    enum_def.push_str("impl serde::Serialize for CategoryGroup {\n");
    enum_def.push_str("    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n");
    enum_def.push_str("    where\n");
    enum_def.push_str("        S: serde::Serializer,\n");
    enum_def.push_str("    {\n");
    enum_def.push_str("        serializer.serialize_str(match self {\n");
    for Group { name, .. } in groups {
        let enum_name = name
            .chars()
            .filter(|c| c.is_alphanumeric())
            .filter(|c| !c.is_whitespace())
            .collect::<String>();
        enum_def.push_str(&format!(
            "            Self::{} => \"{}\",\n",
            enum_name, name
        ));
    }
    enum_def.push_str("        })\n");
    enum_def.push_str("    }\n");
    enum_def.push_str("}\n");

    // Manually implement Deserialize
    enum_def.push_str("\n");
    enum_def.push_str("#[cfg(feature = \"serde\")]\n");
    enum_def.push_str("impl<'de> serde::Deserialize<'de> for CategoryGroup {\n");
    enum_def.push_str("    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n");
    enum_def.push_str("    where\n");
    enum_def.push_str("        D: serde::Deserializer<'de>,\n");
    enum_def.push_str("    {\n");
    enum_def.push_str("        let s = <&str>::deserialize(deserializer)?;\n");
    enum_def.push_str("        match s {\n");
    for Group { name, .. } in groups {
        let enum_name = name
            .chars()
            .filter(|c| c.is_alphanumeric())
            .filter(|c| !c.is_whitespace())
            .collect::<String>();
        enum_def.push_str(&format!(
            "            \"{}\" => Ok(Self::{}),\n",
            name, enum_name
        ));
    }
    enum_def.push_str("            _ => Err(serde::de::Error::unknown_variant(s, &[\n");
    for (i, Group { name, .. }) in groups.iter().enumerate() {
        if i == groups.len() - 1 {
            enum_def.push_str(&format!("                \"{}\",\n", name));
        } else {
            enum_def.push_str(&format!("                \"{}\",\n", name));
        }
    }
    enum_def.push_str("            ])),\n");
    enum_def.push_str("        }\n");
    enum_def.push_str("    }\n");
    enum_def.push_str("}\n");

    enum_def
}

fn construct_nzfcc_code_enum(categories: &[Category]) -> String {
    let mut enum_def = String::new();
    enum_def.push_str("// This file is generated by nzfcc-generator. Do not edit manually.\n");
    enum_def.push_str("// Run: cargo run -p nzfcc-generator to regenerate\n\n");
    enum_def.push_str("/// All possible New Zealand Financial Category Codes (NZFCC) codes, as defined by the NZFCC org [https://nzfcc.org/explore/](https://nzfcc.org/explore/).\n");
    enum_def.push_str("#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n");
    enum_def.push_str("#[non_exhaustive]\n");
    enum_def.push_str("pub enum NzfccCode {\n");
    for Category { name, .. } in categories {
        let enum_name = name
            .split_whitespace()
            .flat_map(|word| {
                let mut chars = word.chars();
                let first = chars.next().map(|c| c.to_ascii_uppercase());
                first.into_iter().chain(chars)
            })
            .filter(|c| c.is_alphanumeric())
            .collect::<String>();

        enum_def.push_str(&format!("    /// The \"{}\" category.\n", name));
        enum_def.push_str(&format!("    {},\n", enum_name));
    }
    enum_def.push_str("}\n");

    // Add a conversion from NzfccCode to Id
    enum_def.push_str("\n");
    enum_def.push_str("impl NzfccCode {\n");
    enum_def.push_str("    /// Returns the ID of the NZFCC code.\n");
    enum_def.push_str("    /// NZFCC IDs start with `nzfcc_`.\n");
    enum_def.push_str("    pub const fn id(&self) -> &'static str {\n");
    enum_def.push_str("        match self {\n");
    for Category { name, id, .. } in categories {
        let enum_name = name
            .split_whitespace()
            .flat_map(|word| {
                let mut chars = word.chars();
                let first = chars.next().map(|c| c.to_ascii_uppercase());
                first.into_iter().chain(chars)
            })
            .filter(|c| c.is_alphanumeric())
            .collect::<String>();
        enum_def.push_str(&format!("            Self::{} => \"{}\",\n", enum_name, id));
    }
    enum_def.push_str("        }\n");
    enum_def.push_str("    }\n");

    // Add a method to get the associated CategoryGroup
    enum_def.push_str("\n");
    enum_def.push_str("    /// Returns the category group that this NZFCC code belongs to.\n");
    enum_def.push_str("    pub const fn group(&self) -> super::CategoryGroup {\n");
    enum_def.push_str("        match self {\n");
    for Category {
        name,
        groups: cat_groups,
        ..
    } in categories
    {
        let enum_name = name
            .split_whitespace()
            .flat_map(|word| {
                let mut chars = word.chars();
                let first = chars.next().map(|c| c.to_ascii_uppercase());
                first.into_iter().chain(chars)
            })
            .filter(|c| c.is_alphanumeric())
            .collect::<String>();

        // Find the matching group enum name
        let group_name = &cat_groups.personal_finance.name;
        let group_enum_name = group_name
            .chars()
            .filter(|c| c.is_alphanumeric())
            .filter(|c| !c.is_whitespace())
            .collect::<String>();

        enum_def.push_str(&format!(
            "            Self::{} => super::CategoryGroup::{},\n",
            enum_name, group_enum_name
        ));
    }
    enum_def.push_str("        }\n");
    enum_def.push_str("    }\n");
    enum_def.push_str("}\n");

    // Manually implement Serialize
    enum_def.push_str("\n");
    enum_def.push_str("#[cfg(feature = \"serde\")]\n");
    enum_def.push_str("impl serde::Serialize for NzfccCode {\n");
    enum_def.push_str("    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n");
    enum_def.push_str("    where\n");
    enum_def.push_str("        S: serde::Serializer,\n");
    enum_def.push_str("    {\n");
    enum_def.push_str("        serializer.serialize_str(match self {\n");
    for Category { name, .. } in categories {
        let enum_name = name
            .split_whitespace()
            .flat_map(|word| {
                let mut chars = word.chars();
                let first = chars.next().map(|c| c.to_ascii_uppercase());
                first.into_iter().chain(chars)
            })
            .filter(|c| c.is_alphanumeric())
            .collect::<String>();
        enum_def.push_str(&format!(
            "            Self::{} => \"{}\",\n",
            enum_name, name
        ));
    }
    enum_def.push_str("        })\n");
    enum_def.push_str("    }\n");
    enum_def.push_str("}\n");

    // Manually implement Deserialize
    enum_def.push_str("\n");
    enum_def.push_str("#[cfg(feature = \"serde\")]\n");
    enum_def.push_str("impl<'de> serde::Deserialize<'de> for NzfccCode {\n");
    enum_def.push_str("    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n");
    enum_def.push_str("    where\n");
    enum_def.push_str("        D: serde::Deserializer<'de>,\n");
    enum_def.push_str("    {\n");
    enum_def.push_str("        let s = <&str>::deserialize(deserializer)?;\n");
    enum_def.push_str("        match s {\n");
    for Category { name, .. } in categories {
        let enum_name = name
            .split_whitespace()
            .flat_map(|word| {
                let mut chars = word.chars();
                let first = chars.next().map(|c| c.to_ascii_uppercase());
                first.into_iter().chain(chars)
            })
            .filter(|c| c.is_alphanumeric())
            .collect::<String>();
        enum_def.push_str(&format!(
            "            \"{}\" => Ok(Self::{}),\n",
            name, enum_name
        ));
    }

    // Generate the list of all valid variant names for error messages
    enum_def.push_str("            _ => {\n");
    enum_def.push_str("                const VARIANTS: &[&str] = &[\n");
    for Category { name, .. } in categories {
        enum_def.push_str(&format!("                    \"{}\",\n", name));
    }
    enum_def.push_str("                ];\n");
    enum_def.push_str("                Err(serde::de::Error::unknown_variant(s, VARIANTS))\n");
    enum_def.push_str("            }\n");
    enum_def.push_str("        }\n");
    enum_def.push_str("    }\n");
    enum_def.push_str("}\n");

    enum_def
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("Downloading categories from {}...", CATEGORIES_URL);

    // Download categories.json
    let response = reqwest::blocking::get(CATEGORIES_URL)?;
    let categories_json = response.text()?;

    // Parse the JSON
    let categories: Vec<Category> = serde_json::from_str(&categories_json)?;
    println!("Successfully downloaded {} categories", categories.len());

    // Determine workspace root early
    let manifest_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    let workspace_root = manifest_dir.parent().unwrap().parent().unwrap();

    // Save formatted JSON to repository for version tracking
    let categories_json_path = workspace_root.join("categories.json");
    let formatted_json = serde_json::to_string_pretty(&categories)?;
    std::fs::write(&categories_json_path, formatted_json)?;
    println!("Saved categories.json to repository");

    // Find all unique group names
    let mut seen_groups = HashSet::new();
    let filtered_groups = categories
        .iter()
        .map(|cat| &cat.groups.personal_finance)
        .filter(|group| seen_groups.insert(&group.id))
        .cloned()
        .collect::<Vec<Group>>();

    println!("Found {} unique category groups", filtered_groups.len());

    // Generate the enums
    let group_enum = construct_group_enum(&filtered_groups, &categories);
    let nzfcc_enum = construct_nzfcc_code_enum(&categories);

    // Determine output directory
    let output_dir = workspace_root.join("crates/nzfcc/src/generated");

    // Write files
    println!("Writing generated files to {}...", output_dir.display());
    std::fs::create_dir_all(&output_dir)?;

    let category_groups_path = output_dir.join("category_groups.rs");
    let mut f = File::create(&category_groups_path)?;
    f.write_all(group_enum.as_bytes())?;
    println!("Wrote category_groups.rs");

    let nzfcc_codes_path = output_dir.join("nzfcc_codes.rs");
    let mut f = File::create(&nzfcc_codes_path)?;
    f.write_all(nzfcc_enum.as_bytes())?;
    println!("Wrote nzfcc_codes.rs");

    // Run cargo fmt on the generated files
    println!("Formatting generated files...");
    let fmt_status = Command::new("cargo")
        .arg("fmt")
        .arg("--")
        .arg(&category_groups_path)
        .arg(&nzfcc_codes_path)
        .status();

    match fmt_status {
        Ok(status) if status.success() => {
            println!("Formatted successfully");
        }
        Ok(status) => {
            eprintln!("cargo fmt exited with status: {}", status);
        }
        Err(e) => {
            eprintln!("Failed to run cargo fmt: {}", e);
            eprintln!("Generated files may not be formatted");
        }
    }

    println!("\nCode generation complete!");
    println!("Generated {} category groups", filtered_groups.len());
    println!("Generated {} NZFCC codes", categories.len());

    Ok(())
}
