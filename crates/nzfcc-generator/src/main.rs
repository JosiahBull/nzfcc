//! Code generator for the NZFCC crate.
//!
//! This tool downloads the latest NZFCC categories from nzfcc.org and generates
//! Rust enum definitions for use in the nzfcc crate.

use std::collections::HashSet;
use std::fs::File;
use std::io::Write;
use std::path::PathBuf;
use std::process::Command;

const CATEGORIES_URL: &str = "https://nzfcc.org/downloads/categories.json";

#[derive(Debug, serde::Deserialize, serde::Serialize, Clone)]
#[serde(deny_unknown_fields)]
struct Category {
    #[serde(rename = "_id")]
    id: String,
    name: String,
    groups: Groups,
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Clone)]
#[serde(deny_unknown_fields)]
struct Groups {
    personal_finance: Group,
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Clone)]
#[serde(deny_unknown_fields)]
struct Group {
    #[serde(rename = "_id")]
    id: String,
    name: String,
}

fn construct_group_enum(groups: &[Group], categories: &[Category]) -> String {
    let mut enum_def =
        String::from("// This file is generated by nzfcc-generator. Do not edit manually.\n");
    enum_def.push_str("// Run: cargo run -p nzfcc-generator to regenerate\n\n");
    enum_def.push_str("/// An enum of the possible NZFCC category groups.\n");
    enum_def.push_str("#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord)]\n");
    enum_def.push_str("#[non_exhaustive]\n");
    enum_def.push_str("#[cfg_attr(feature = \"arbitrary\", derive(arbitrary::Arbitrary))]\n");
    enum_def.push_str("pub enum CategoryGroup {\n");
    for Group { name, .. } in groups {
        let enum_name = name
            .chars()
            .filter(|c| c.is_alphanumeric())
            .filter(|c| !c.is_whitespace())
            .collect::<String>();
        enum_def.push_str(&format!("    /// The \"{}\" group.\n", name));
        enum_def.push_str(&format!("    {},\n", enum_name));
    }
    enum_def.push_str("}\n");

    // Generate static arrays for each group containing all codes in that group
    enum_def.push_str("\n");
    for Group { name, id } in groups {
        let group_enum_name = name
            .chars()
            .filter(|c| c.is_alphanumeric())
            .filter(|c| !c.is_whitespace())
            .collect::<String>();

        // Find all categories that belong to this group
        let codes_in_group: Vec<String> = categories
            .iter()
            .filter(|cat| cat.groups.personal_finance.id == *id)
            .map(|cat| {
                cat.name
                    .split_whitespace()
                    .flat_map(|word| {
                        let mut chars = word.chars();
                        let first = chars.next().map(|c| c.to_ascii_uppercase());
                        first.into_iter().chain(chars)
                    })
                    .filter(|c| c.is_alphanumeric())
                    .collect::<String>()
            })
            .collect();

        let const_name = format!("CODES_{}", group_enum_name.to_uppercase());
        enum_def.push_str(&format!("const {}: &[super::NzfccCode] = &[\n", const_name));
        for code in &codes_in_group {
            enum_def.push_str(&format!("    super::NzfccCode::{},\n", code));
        }
        enum_def.push_str("];\n\n");
    }

    // Add a conversion from CategoryGroup to Id
    enum_def.push_str("impl CategoryGroup {\n");
    enum_def.push_str("    /// Returns the ID of the category group.\n");
    enum_def.push_str("    /// Category group ID strings are always prefixed by `group_`.\n");
    enum_def.push_str("    pub const fn id(&self) -> &'static str {\n");
    enum_def.push_str("        match self {\n");
    for Group { name, id } in groups {
        let enum_name = name
            .chars()
            .filter(|c| c.is_alphanumeric())
            .filter(|c| !c.is_whitespace())
            .collect::<String>();
        enum_def.push_str(&format!("            Self::{} => \"{}\",\n", enum_name, id));
    }
    enum_def.push_str("        }\n");
    enum_def.push_str("    }\n");

    // Add method to get all codes in this group
    enum_def.push_str("\n");
    enum_def.push_str("    /// Returns all NZFCC codes that belong to this category group.\n");
    enum_def.push_str("    pub const fn codes(&self) -> &'static [super::NzfccCode] {\n");
    enum_def.push_str("        match self {\n");
    for Group { name, .. } in groups {
        let enum_name = name
            .chars()
            .filter(|c| c.is_alphanumeric())
            .filter(|c| !c.is_whitespace())
            .collect::<String>();
        let const_name = format!("CODES_{}", enum_name.to_uppercase());
        enum_def.push_str(&format!(
            "            Self::{} => {},\n",
            enum_name, const_name
        ));
    }
    enum_def.push_str("        }\n");
    enum_def.push_str("    }\n");
    enum_def.push_str("}\n");

    // Manually implement Serialize
    enum_def.push_str("\n");
    enum_def.push_str("#[cfg(feature = \"serde\")]\n");
    enum_def.push_str("impl serde::Serialize for CategoryGroup {\n");
    enum_def.push_str("    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n");
    enum_def.push_str("    where\n");
    enum_def.push_str("        S: serde::Serializer,\n");
    enum_def.push_str("    {\n");
    enum_def.push_str("        serializer.serialize_str(match self {\n");
    for Group { name, .. } in groups {
        let enum_name = name
            .chars()
            .filter(|c| c.is_alphanumeric())
            .filter(|c| !c.is_whitespace())
            .collect::<String>();
        enum_def.push_str(&format!(
            "            Self::{} => \"{}\",\n",
            enum_name, name
        ));
    }
    enum_def.push_str("        })\n");
    enum_def.push_str("    }\n");
    enum_def.push_str("}\n");

    // Manually implement Deserialize
    enum_def.push_str("\n");
    enum_def.push_str("#[cfg(feature = \"serde\")]\n");
    enum_def.push_str("impl<'de> serde::Deserialize<'de> for CategoryGroup {\n");
    enum_def.push_str("    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n");
    enum_def.push_str("    where\n");
    enum_def.push_str("        D: serde::Deserializer<'de>,\n");
    enum_def.push_str("    {\n");
    enum_def.push_str("        let s = <&str>::deserialize(deserializer)?;\n");
    enum_def.push_str("        match s {\n");
    for Group { name, .. } in groups {
        let enum_name = name
            .chars()
            .filter(|c| c.is_alphanumeric())
            .filter(|c| !c.is_whitespace())
            .collect::<String>();
        enum_def.push_str(&format!(
            "            \"{}\" => Ok(Self::{}),\n",
            name, enum_name
        ));
    }
    enum_def.push_str("            _ => Err(serde::de::Error::unknown_variant(s, &[\n");
    for (i, Group { name, .. }) in groups.iter().enumerate() {
        if i == groups.len() - 1 {
            enum_def.push_str(&format!("                \"{}\",\n", name));
        } else {
            enum_def.push_str(&format!("                \"{}\",\n", name));
        }
    }
    enum_def.push_str("            ])),\n");
    enum_def.push_str("        }\n");
    enum_def.push_str("    }\n");
    enum_def.push_str("}\n");

    // Add Display implementation
    enum_def.push_str("\n");
    enum_def.push_str("impl std::fmt::Display for CategoryGroup {\n");
    enum_def.push_str("    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n");
    enum_def.push_str("        f.write_str(match self {\n");
    for Group { name, .. } in groups {
        let enum_name = name
            .chars()
            .filter(|c| c.is_alphanumeric())
            .filter(|c| !c.is_whitespace())
            .collect::<String>();
        enum_def.push_str(&format!(
            "            Self::{} => \"{}\",\n",
            enum_name, name
        ));
    }
    enum_def.push_str("        })\n");
    enum_def.push_str("    }\n");
    enum_def.push_str("}\n");

    // Add FromStr implementation
    enum_def.push_str("\n");
    enum_def.push_str("/// Error returned when parsing a CategoryGroup from a string fails.\n");
    enum_def.push_str("#[derive(Debug, Clone, PartialEq, Eq)]\n");
    enum_def.push_str("pub struct ParseCategoryGroupError {\n");
    enum_def.push_str("    input: String,\n");
    enum_def.push_str("}\n\n");
    enum_def.push_str("impl std::fmt::Display for ParseCategoryGroupError {\n");
    enum_def.push_str("    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n");
    enum_def.push_str("        write!(f, \"unknown category group: '{}'\", self.input)\n");
    enum_def.push_str("    }\n");
    enum_def.push_str("}\n\n");
    enum_def.push_str("impl std::error::Error for ParseCategoryGroupError {}\n");

    enum_def.push_str("\n");
    enum_def.push_str("impl std::str::FromStr for CategoryGroup {\n");
    enum_def.push_str("    type Err = ParseCategoryGroupError;\n\n");
    enum_def.push_str("    fn from_str(s: &str) -> Result<Self, Self::Err> {\n");
    enum_def.push_str("        match s {\n");
    for Group { name, .. } in groups {
        let enum_name = name
            .chars()
            .filter(|c| c.is_alphanumeric())
            .filter(|c| !c.is_whitespace())
            .collect::<String>();
        enum_def.push_str(&format!(
            "            \"{}\" => Ok(Self::{}),\n",
            name, enum_name
        ));
    }
    enum_def.push_str("            _ => Err(ParseCategoryGroupError {\n");
    enum_def.push_str("                input: s.to_string(),\n");
    enum_def.push_str("            }),\n");
    enum_def.push_str("        }\n");
    enum_def.push_str("    }\n");
    enum_def.push_str("}\n");

    // Add TryFrom<String> implementation
    enum_def.push_str("\n");
    enum_def.push_str("impl TryFrom<String> for CategoryGroup {\n");
    enum_def.push_str("    type Error = ParseCategoryGroupError;\n\n");
    enum_def.push_str("    fn try_from(s: String) -> Result<Self, Self::Error> {\n");
    enum_def.push_str("        s.parse()\n");
    enum_def.push_str("    }\n");
    enum_def.push_str("}\n");

    // Add TryFrom<&str> implementation
    enum_def.push_str("\n");
    enum_def.push_str("impl TryFrom<&str> for CategoryGroup {\n");
    enum_def.push_str("    type Error = ParseCategoryGroupError;\n\n");
    enum_def.push_str("    fn try_from(s: &str) -> Result<Self, Self::Error> {\n");
    enum_def.push_str("        s.parse()\n");
    enum_def.push_str("    }\n");
    enum_def.push_str("}\n");

    // Add iteration support
    enum_def.push_str("\n");
    enum_def.push_str("impl CategoryGroup {\n");
    enum_def.push_str("    /// Returns a slice containing all possible CategoryGroup values.\n");
    enum_def.push_str("    pub const fn values() -> &'static [Self] {\n");
    enum_def.push_str("        &[\n");
    for Group { name, .. } in groups {
        let enum_name = name
            .chars()
            .filter(|c| c.is_alphanumeric())
            .filter(|c| !c.is_whitespace())
            .collect::<String>();
        enum_def.push_str(&format!("            Self::{},\n", enum_name));
    }
    enum_def.push_str("        ]\n");
    enum_def.push_str("    }\n");

    // Add variant_name method
    enum_def.push_str("\n");
    enum_def.push_str(
        "    /// Returns the variant name as a static string (e.g., \"ProfessionalServices\").\n",
    );
    enum_def.push_str("    /// This is the Rust enum variant name, not the display name.\n");
    enum_def.push_str("    pub const fn variant_name(&self) -> &'static str {\n");
    enum_def.push_str("        match self {\n");
    for Group { name, .. } in groups {
        let enum_name = name
            .chars()
            .filter(|c| c.is_alphanumeric())
            .filter(|c| !c.is_whitespace())
            .collect::<String>();
        enum_def.push_str(&format!(
            "            Self::{} => \"{}\",\n",
            enum_name, enum_name
        ));
    }
    enum_def.push_str("        }\n");
    enum_def.push_str("    }\n");

    // Add iter method
    enum_def.push_str("\n");
    enum_def.push_str("    /// Returns an iterator over all CategoryGroup values.\n");
    enum_def.push_str("    pub fn iter() -> impl Iterator<Item = Self> {\n");
    enum_def.push_str("        Self::values().iter().copied()\n");
    enum_def.push_str("    }\n");
    enum_def.push_str("}\n");

    // Add AsRef<str> implementation
    enum_def.push_str("\n");
    enum_def.push_str("impl AsRef<str> for CategoryGroup {\n");
    enum_def.push_str("    fn as_ref(&self) -> &str {\n");
    enum_def.push_str("        match self {\n");
    for Group { name, .. } in groups {
        let enum_name = name
            .chars()
            .filter(|c| c.is_alphanumeric())
            .filter(|c| !c.is_whitespace())
            .collect::<String>();
        enum_def.push_str(&format!(
            "            Self::{} => \"{}\",\n",
            enum_name, name
        ));
    }
    enum_def.push_str("        }\n");
    enum_def.push_str("    }\n");
    enum_def.push_str("}\n");

    // Add From<CategoryGroup> for &'static str implementation
    enum_def.push_str("\n");
    enum_def.push_str("impl From<CategoryGroup> for &'static str {\n");
    enum_def.push_str("    fn from(group: CategoryGroup) -> Self {\n");
    enum_def.push_str("        match group {\n");
    for Group { name, .. } in groups {
        let enum_name = name
            .chars()
            .filter(|c| c.is_alphanumeric())
            .filter(|c| !c.is_whitespace())
            .collect::<String>();
        enum_def.push_str(&format!(
            "            CategoryGroup::{} => \"{}\",\n",
            enum_name, name
        ));
    }
    enum_def.push_str("        }\n");
    enum_def.push_str("    }\n");
    enum_def.push_str("}\n");

    // Add clap::ValueEnum implementation
    enum_def.push_str("\n");
    enum_def.push_str("#[cfg(feature = \"clap\")]\n");
    enum_def.push_str("impl clap::ValueEnum for CategoryGroup {\n");
    enum_def.push_str("    fn value_variants<'a>() -> &'a [Self] {\n");
    enum_def.push_str("        Self::values()\n");
    enum_def.push_str("    }\n\n");
    enum_def
        .push_str("    fn to_possible_value(&self) -> Option<clap::builder::PossibleValue> {\n");
    enum_def.push_str("        Some(clap::builder::PossibleValue::new(match self {\n");
    for Group { name, .. } in groups {
        let enum_name = name
            .chars()
            .filter(|c| c.is_alphanumeric())
            .filter(|c| !c.is_whitespace())
            .collect::<String>();
        enum_def.push_str(&format!(
            "            Self::{} => \"{}\",\n",
            enum_name, name
        ));
    }
    enum_def.push_str("        }))\n");
    enum_def.push_str("    }\n");
    enum_def.push_str("}\n");

    enum_def
}

fn construct_nzfcc_code_enum(categories: &[Category]) -> String {
    let mut enum_def = String::new();
    enum_def.push_str("// This file is generated by nzfcc-generator. Do not edit manually.\n");
    enum_def.push_str("// Run: cargo run -p nzfcc-generator to regenerate\n\n");
    enum_def.push_str("/// All possible New Zealand Financial Category Codes (NZFCC) codes, as defined by the NZFCC org [https://nzfcc.org/explore/](https://nzfcc.org/explore/).\n");
    enum_def.push_str("#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord)]\n");
    enum_def.push_str("#[non_exhaustive]\n");
    enum_def.push_str("#[cfg_attr(feature = \"arbitrary\", derive(arbitrary::Arbitrary))]\n");
    enum_def.push_str("pub enum NzfccCode {\n");
    for Category { name, .. } in categories {
        let enum_name = name
            .split_whitespace()
            .flat_map(|word| {
                let mut chars = word.chars();
                let first = chars.next().map(|c| c.to_ascii_uppercase());
                first.into_iter().chain(chars)
            })
            .filter(|c| c.is_alphanumeric())
            .collect::<String>();

        enum_def.push_str(&format!("    /// The \"{}\" category.\n", name));
        enum_def.push_str(&format!("    {},\n", enum_name));
    }
    enum_def.push_str("}\n");

    // Add a conversion from NzfccCode to Id
    enum_def.push_str("\n");
    enum_def.push_str("impl NzfccCode {\n");
    enum_def.push_str("    /// Returns the ID of the NZFCC code.\n");
    enum_def.push_str("    /// NZFCC IDs start with `nzfcc_`.\n");
    enum_def.push_str("    pub const fn id(&self) -> &'static str {\n");
    enum_def.push_str("        match self {\n");
    for Category { name, id, .. } in categories {
        let enum_name = name
            .split_whitespace()
            .flat_map(|word| {
                let mut chars = word.chars();
                let first = chars.next().map(|c| c.to_ascii_uppercase());
                first.into_iter().chain(chars)
            })
            .filter(|c| c.is_alphanumeric())
            .collect::<String>();
        enum_def.push_str(&format!("            Self::{} => \"{}\",\n", enum_name, id));
    }
    enum_def.push_str("        }\n");
    enum_def.push_str("    }\n");

    // Add a method to get the associated CategoryGroup
    enum_def.push_str("\n");
    enum_def.push_str("    /// Returns the category group that this NZFCC code belongs to.\n");
    enum_def.push_str("    pub const fn group(&self) -> super::CategoryGroup {\n");
    enum_def.push_str("        match self {\n");
    for Category {
        name,
        groups: cat_groups,
        ..
    } in categories
    {
        let enum_name = name
            .split_whitespace()
            .flat_map(|word| {
                let mut chars = word.chars();
                let first = chars.next().map(|c| c.to_ascii_uppercase());
                first.into_iter().chain(chars)
            })
            .filter(|c| c.is_alphanumeric())
            .collect::<String>();

        // Find the matching group enum name
        let group_name = &cat_groups.personal_finance.name;
        let group_enum_name = group_name
            .chars()
            .filter(|c| c.is_alphanumeric())
            .filter(|c| !c.is_whitespace())
            .collect::<String>();

        enum_def.push_str(&format!(
            "            Self::{} => super::CategoryGroup::{},\n",
            enum_name, group_enum_name
        ));
    }
    enum_def.push_str("        }\n");
    enum_def.push_str("    }\n");
    enum_def.push_str("}\n");

    // Manually implement Serialize
    enum_def.push_str("\n");
    enum_def.push_str("#[cfg(feature = \"serde\")]\n");
    enum_def.push_str("impl serde::Serialize for NzfccCode {\n");
    enum_def.push_str("    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n");
    enum_def.push_str("    where\n");
    enum_def.push_str("        S: serde::Serializer,\n");
    enum_def.push_str("    {\n");
    enum_def.push_str("        serializer.serialize_str(match self {\n");
    for Category { name, .. } in categories {
        let enum_name = name
            .split_whitespace()
            .flat_map(|word| {
                let mut chars = word.chars();
                let first = chars.next().map(|c| c.to_ascii_uppercase());
                first.into_iter().chain(chars)
            })
            .filter(|c| c.is_alphanumeric())
            .collect::<String>();
        enum_def.push_str(&format!(
            "            Self::{} => \"{}\",\n",
            enum_name, name
        ));
    }
    enum_def.push_str("        })\n");
    enum_def.push_str("    }\n");
    enum_def.push_str("}\n");

    // Manually implement Deserialize
    enum_def.push_str("\n");
    enum_def.push_str("#[cfg(feature = \"serde\")]\n");
    enum_def.push_str("impl<'de> serde::Deserialize<'de> for NzfccCode {\n");
    enum_def.push_str("    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n");
    enum_def.push_str("    where\n");
    enum_def.push_str("        D: serde::Deserializer<'de>,\n");
    enum_def.push_str("    {\n");
    enum_def.push_str("        let s = <&str>::deserialize(deserializer)?;\n");
    enum_def.push_str("        match s {\n");
    for Category { name, .. } in categories {
        let enum_name = name
            .split_whitespace()
            .flat_map(|word| {
                let mut chars = word.chars();
                let first = chars.next().map(|c| c.to_ascii_uppercase());
                first.into_iter().chain(chars)
            })
            .filter(|c| c.is_alphanumeric())
            .collect::<String>();
        enum_def.push_str(&format!(
            "            \"{}\" => Ok(Self::{}),\n",
            name, enum_name
        ));
    }

    // Generate the list of all valid variant names for error messages
    enum_def.push_str("            _ => {\n");
    enum_def.push_str("                const VARIANTS: &[&str] = &[\n");
    for Category { name, .. } in categories {
        enum_def.push_str(&format!("                    \"{}\",\n", name));
    }
    enum_def.push_str("                ];\n");
    enum_def.push_str("                Err(serde::de::Error::unknown_variant(s, VARIANTS))\n");
    enum_def.push_str("            }\n");
    enum_def.push_str("        }\n");
    enum_def.push_str("    }\n");
    enum_def.push_str("}\n");

    // Add Display implementation
    enum_def.push_str("\n");
    enum_def.push_str("impl std::fmt::Display for NzfccCode {\n");
    enum_def.push_str("    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n");
    enum_def.push_str("        f.write_str(match self {\n");
    for Category { name, .. } in categories {
        let enum_name = name
            .split_whitespace()
            .flat_map(|word| {
                let mut chars = word.chars();
                let first = chars.next().map(|c| c.to_ascii_uppercase());
                first.into_iter().chain(chars)
            })
            .filter(|c| c.is_alphanumeric())
            .collect::<String>();
        enum_def.push_str(&format!(
            "            Self::{} => \"{}\",\n",
            enum_name, name
        ));
    }
    enum_def.push_str("        })\n");
    enum_def.push_str("    }\n");
    enum_def.push_str("}\n");

    // Add FromStr implementation
    enum_def.push_str("\n");
    enum_def.push_str("/// Error returned when parsing an NzfccCode from a string fails.\n");
    enum_def.push_str("#[derive(Debug, Clone, PartialEq, Eq)]\n");
    enum_def.push_str("pub struct ParseNzfccCodeError {\n");
    enum_def.push_str("    input: String,\n");
    enum_def.push_str("}\n\n");
    enum_def.push_str("impl std::fmt::Display for ParseNzfccCodeError {\n");
    enum_def.push_str("    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n");
    enum_def.push_str("        write!(f, \"unknown NZFCC code: '{}'\", self.input)\n");
    enum_def.push_str("    }\n");
    enum_def.push_str("}\n\n");
    enum_def.push_str("impl std::error::Error for ParseNzfccCodeError {}\n");

    enum_def.push_str("\n");
    enum_def.push_str("impl std::str::FromStr for NzfccCode {\n");
    enum_def.push_str("    type Err = ParseNzfccCodeError;\n\n");
    enum_def.push_str("    fn from_str(s: &str) -> Result<Self, Self::Err> {\n");
    enum_def.push_str("        match s {\n");
    for Category { name, .. } in categories {
        let enum_name = name
            .split_whitespace()
            .flat_map(|word| {
                let mut chars = word.chars();
                let first = chars.next().map(|c| c.to_ascii_uppercase());
                first.into_iter().chain(chars)
            })
            .filter(|c| c.is_alphanumeric())
            .collect::<String>();
        enum_def.push_str(&format!(
            "            \"{}\" => Ok(Self::{}),\n",
            name, enum_name
        ));
    }
    enum_def.push_str("            _ => Err(ParseNzfccCodeError {\n");
    enum_def.push_str("                input: s.to_string(),\n");
    enum_def.push_str("            }),\n");
    enum_def.push_str("        }\n");
    enum_def.push_str("    }\n");
    enum_def.push_str("}\n");

    // Add TryFrom<String> implementation
    enum_def.push_str("\n");
    enum_def.push_str("impl TryFrom<String> for NzfccCode {\n");
    enum_def.push_str("    type Error = ParseNzfccCodeError;\n\n");
    enum_def.push_str("    fn try_from(s: String) -> Result<Self, Self::Error> {\n");
    enum_def.push_str("        s.parse()\n");
    enum_def.push_str("    }\n");
    enum_def.push_str("}\n");

    // Add TryFrom<&str> implementation
    enum_def.push_str("\n");
    enum_def.push_str("impl TryFrom<&str> for NzfccCode {\n");
    enum_def.push_str("    type Error = ParseNzfccCodeError;\n\n");
    enum_def.push_str("    fn try_from(s: &str) -> Result<Self, Self::Error> {\n");
    enum_def.push_str("        s.parse()\n");
    enum_def.push_str("    }\n");
    enum_def.push_str("}\n");

    // Add iteration support
    enum_def.push_str("\n");
    enum_def.push_str("impl NzfccCode {\n");
    enum_def.push_str("    /// Returns a slice containing all possible NzfccCode values.\n");
    enum_def.push_str("    pub const fn values() -> &'static [Self] {\n");
    enum_def.push_str("        &[\n");
    for Category { name, .. } in categories {
        let enum_name = name
            .split_whitespace()
            .flat_map(|word| {
                let mut chars = word.chars();
                let first = chars.next().map(|c| c.to_ascii_uppercase());
                first.into_iter().chain(chars)
            })
            .filter(|c| c.is_alphanumeric())
            .collect::<String>();
        enum_def.push_str(&format!("            Self::{},\n", enum_name));
    }
    enum_def.push_str("        ]\n");
    enum_def.push_str("    }\n");

    // Add variant_name method
    enum_def.push_str("\n");
    enum_def.push_str(
        "    /// Returns the variant name as a static string (e.g., \"CafesAndRestaurants\").\n",
    );
    enum_def.push_str("    /// This is the Rust enum variant name, not the display name.\n");
    enum_def.push_str("    pub const fn variant_name(&self) -> &'static str {\n");
    enum_def.push_str("        match self {\n");
    for Category { name, .. } in categories {
        let enum_name = name
            .split_whitespace()
            .flat_map(|word| {
                let mut chars = word.chars();
                let first = chars.next().map(|c| c.to_ascii_uppercase());
                first.into_iter().chain(chars)
            })
            .filter(|c| c.is_alphanumeric())
            .collect::<String>();
        enum_def.push_str(&format!(
            "            Self::{} => \"{}\",\n",
            enum_name, enum_name
        ));
    }
    enum_def.push_str("        }\n");
    enum_def.push_str("    }\n");

    // Add iter method
    enum_def.push_str("\n");
    enum_def.push_str("    /// Returns an iterator over all NzfccCode values.\n");
    enum_def.push_str("    pub fn iter() -> impl Iterator<Item = Self> {\n");
    enum_def.push_str("        Self::values().iter().copied()\n");
    enum_def.push_str("    }\n");
    enum_def.push_str("}\n");

    // Add AsRef<str> implementation
    enum_def.push_str("\n");
    enum_def.push_str("impl AsRef<str> for NzfccCode {\n");
    enum_def.push_str("    fn as_ref(&self) -> &str {\n");
    enum_def.push_str("        match self {\n");
    for Category { name, .. } in categories {
        let enum_name = name
            .split_whitespace()
            .flat_map(|word| {
                let mut chars = word.chars();
                let first = chars.next().map(|c| c.to_ascii_uppercase());
                first.into_iter().chain(chars)
            })
            .filter(|c| c.is_alphanumeric())
            .collect::<String>();
        enum_def.push_str(&format!(
            "            Self::{} => \"{}\",\n",
            enum_name, name
        ));
    }
    enum_def.push_str("        }\n");
    enum_def.push_str("    }\n");
    enum_def.push_str("}\n");

    // Add From<NzfccCode> for &'static str implementation
    enum_def.push_str("\n");
    enum_def.push_str("impl From<NzfccCode> for &'static str {\n");
    enum_def.push_str("    fn from(code: NzfccCode) -> Self {\n");
    enum_def.push_str("        match code {\n");
    for Category { name, .. } in categories {
        let enum_name = name
            .split_whitespace()
            .flat_map(|word| {
                let mut chars = word.chars();
                let first = chars.next().map(|c| c.to_ascii_uppercase());
                first.into_iter().chain(chars)
            })
            .filter(|c| c.is_alphanumeric())
            .collect::<String>();
        enum_def.push_str(&format!(
            "            NzfccCode::{} => \"{}\",\n",
            enum_name, name
        ));
    }
    enum_def.push_str("        }\n");
    enum_def.push_str("    }\n");
    enum_def.push_str("}\n");

    // Add clap::ValueEnum implementation
    enum_def.push_str("\n");
    enum_def.push_str("#[cfg(feature = \"clap\")]\n");
    enum_def.push_str("impl clap::ValueEnum for NzfccCode {\n");
    enum_def.push_str("    fn value_variants<'a>() -> &'a [Self] {\n");
    enum_def.push_str("        Self::values()\n");
    enum_def.push_str("    }\n\n");
    enum_def
        .push_str("    fn to_possible_value(&self) -> Option<clap::builder::PossibleValue> {\n");
    enum_def.push_str("        Some(clap::builder::PossibleValue::new(match self {\n");
    for Category { name, .. } in categories {
        let enum_name = name
            .split_whitespace()
            .flat_map(|word| {
                let mut chars = word.chars();
                let first = chars.next().map(|c| c.to_ascii_uppercase());
                first.into_iter().chain(chars)
            })
            .filter(|c| c.is_alphanumeric())
            .collect::<String>();
        enum_def.push_str(&format!(
            "            Self::{} => \"{}\",\n",
            enum_name, name
        ));
    }
    enum_def.push_str("        }))\n");
    enum_def.push_str("    }\n");
    enum_def.push_str("}\n");

    enum_def
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("Downloading categories from {}...", CATEGORIES_URL);

    // Download categories.json
    let response = reqwest::blocking::get(CATEGORIES_URL)?;
    let categories_json = response.text()?;

    // Parse the JSON
    let categories: Vec<Category> = serde_json::from_str(&categories_json)?;
    println!("Successfully downloaded {} categories", categories.len());

    // Determine workspace root early
    let manifest_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    let workspace_root = manifest_dir.parent().unwrap().parent().unwrap();

    // Save formatted JSON to repository for version tracking
    let categories_json_path = workspace_root.join("categories.json");
    let formatted_json = serde_json::to_string_pretty(&categories)?;
    std::fs::write(&categories_json_path, formatted_json)?;
    println!("Saved categories.json to repository");

    // Find all unique group names
    let mut seen_groups = HashSet::new();
    let filtered_groups = categories
        .iter()
        .map(|cat| &cat.groups.personal_finance)
        .filter(|group| seen_groups.insert(&group.id))
        .cloned()
        .collect::<Vec<Group>>();

    println!("Found {} unique category groups", filtered_groups.len());

    // Generate the enums
    let group_enum = construct_group_enum(&filtered_groups, &categories);
    let nzfcc_enum = construct_nzfcc_code_enum(&categories);

    // Determine output directory
    let output_dir = workspace_root.join("crates/nzfcc/src/generated");

    // Write files
    println!("Writing generated files to {}...", output_dir.display());
    std::fs::create_dir_all(&output_dir)?;

    let category_groups_path = output_dir.join("category_groups.rs");
    let mut f = File::create(&category_groups_path)?;
    f.write_all(group_enum.as_bytes())?;
    println!("Wrote category_groups.rs");

    let nzfcc_codes_path = output_dir.join("nzfcc_codes.rs");
    let mut f = File::create(&nzfcc_codes_path)?;
    f.write_all(nzfcc_enum.as_bytes())?;
    println!("Wrote nzfcc_codes.rs");

    // Run cargo fmt on the generated files
    println!("Formatting generated files...");
    let fmt_status = Command::new("cargo")
        .arg("fmt")
        .arg("--")
        .arg(&category_groups_path)
        .arg(&nzfcc_codes_path)
        .status();

    match fmt_status {
        Ok(status) if status.success() => {
            println!("Formatted successfully");
        }
        Ok(status) => {
            eprintln!("cargo fmt exited with status: {}", status);
        }
        Err(e) => {
            eprintln!("Failed to run cargo fmt: {}", e);
            eprintln!("Generated files may not be formatted");
        }
    }

    println!("\nCode generation complete!");
    println!("Generated {} category groups", filtered_groups.len());
    println!("Generated {} NZFCC codes", categories.len());

    Ok(())
}
